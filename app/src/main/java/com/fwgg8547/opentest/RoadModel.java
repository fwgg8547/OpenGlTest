package com.fwgg8547.opentest;

import java.util.List;
import java.util.ArrayList;
import java.util.*;

// rag = do * pi / 180
// x = r * cos 
// y = r * sin

public class RoadModel
{
	private static final String TAG = "RoadModel";
	private static RoadModel instance;
	private static final int ROADNUM = 11;
	private static final int SCREENHIGHT = 2000;
	public class Item {
		public int mId;
		public boolean isDeleted;
		public Sprite mSprite;
		
		public Item(){
			isDeleted = false;
		}
	}
	
	private List<Item> mRoad;
	
	public static RoadModel getInstance(){
		if(instance == null){
			instance = new RoadModel();
		}
		
		return instance;
	}
	
	private RoadModel(){
		mRoad = new ArrayList<Item>();
	}
	
	public void initialize(int num){
		for(int i=0; i<num; i++){
			Sprite s = new Sprite(i);
			s.translate(500, SCREENHIGHT - i*200);
			Item it = new Item();
			it.mId = i;
			it.mSprite = s;
			mRoad.add(it);
		}
	}
	
	public Item removeTopRoadItem(){
		Item i = mRoad.remove(0);
		int id = i.mId;
		Item last = mRoad.get(mRoad.size()-1);
		Item ni = new Item();
		Sprite ns = new Sprite(id);
		ns.translate(500, last.mSprite.getPositionY() - 200);
		ni.mId = id;
		ni.mSprite = ns;
		mRoad.add(ni);
		return i;
	}
	
	public float[] getRoadVert(int length){
		int i = 1;
		float[] vert = null;
		Iterator ite = mRoad.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(vert == null) {
				vert = it.mSprite.getTransformedVertices();
			} else {
				vert = floatArrayConcat(vert, it.mSprite.getTransformedVertices());
			}
			if(i >= length){
				break;
			} else {
				i++;
			}
		}
		return vert;
	}
	
	public short[] getRoadIndex(int length){
		int i = 1;
		short[] index = null;
		Iterator ite = mRoad.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(index == null) {
				index = it.mSprite.getIndices();
			} else {
				index = shortArrayConcat(index, it.mSprite.getIndices());
			}
			
			if(i >= length){
				break;
			} else {
				i++;
			}
		}
		return index;
	}
	
	public float[] getUvs(){
		float[] def = new float[] {
      0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
		};

		float[] ux = null;
		for(int i=0; i<mRoad.size();i++){

			if(ux == null){
				ux = def;
			} else {
				ux = floatArrayConcat(ux, def);
			}

		}

		return ux;
	}
	
	synchronized public boolean conflict(float x, float y){
		boolean isConflict = false;
		
		Iterator ite = mRoad.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.mSprite.conflict(x, y)){
				i.isDeleted = true;
				isConflict = true;
			}
		}
		
		return isConflict;
	}
	
	synchronized public void delete(){
		Iterator ite = mRoad.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.isDeleted){
				Lg.w(TAG, "delete item id ="+i.mId);
				ite.remove();
				
			}
		}
	}
	
	synchronized public void roll(double r, int deg){
		double rad = Math.PI * deg /180;
		float x = (float)(r*Math.cos(rad));
		float y = (float)(r*Math.sin(rad));
		Iterator ite = mRoad.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			i.mSprite.translateTemp(x,y);
		}
	}
	
	synchronized public void scrollup(int delta){
		Iterator ite = mRoad.iterator(); 
		float y = 0;
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			
			float ny = i.mSprite.translateDelta(delta);
			y = (ny > y)? ny:y;
		}
		
		if(y > SCREENHIGHT){
			removeTopRoadItem();
		}
	}
	
	private float[] floatArrayConcat(float[] a, float[] b){
		float res[] = new float[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}

	private short[] 
	shortArrayConcat(short[] a, short[] b){
		short res[] = new short[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}
	
}
