package com.fwgg8547.opentest;
import android.graphics.*;
import org.apache.http.*;
import android.text.*;
import java.util.*;

public class TreeManager
{
	private static final String TAG = "TreeManager";
	public static final int MAX_LEVEL = 4;
	private Cell[] mTree;
	private int[] mPow4;
	private int mCellNum;
	private RectF mScreen;
	private float mUnitW;
	private float mUnitH;
	private boolean mIsInitialized;
	
	public TreeManager(){
		mIsInitialized = false;
		mPow4 = new int[MAX_LEVEL+2];
		mPow4[0] = 1;
		int i;
		for(i = 1; i < MAX_LEVEL+2; i++){
			mPow4[i] = mPow4[i-1]*4;
		}
		
		mCellNum = (mPow4[MAX_LEVEL+1]-1)/3;
		mTree = new Cell[mCellNum];

		Lg.i(TAG, "cell num " + mCellNum);
		Lg.i(TAG, "unit w h " + mUnitW +";"+mUnitH);
		
	}
	
	public void initialize(RectF screen){
		if(mIsInitialized){
			return;
		}
		Lg.i(TAG, "i");
		mScreen = screen;
		mUnitH = mScreen.height()/(1<<MAX_LEVEL);
		mUnitW = mScreen.width()/(1<<MAX_LEVEL);
		Lg.i(TAG, "unit w h "+mUnitW+"|"+mUnitH);
		mIsInitialized = true;
	}
	
	public void registModel(SpriteModel m){
		Iterator it = m.iterator();
		while(it.hasNext()){
			Item i = (Item)it.next();
			register(i);
		}
	}
	
	// l0:0 
	// l1:0 1 2 3 _5
	// l2:0 1 2 3 ... 15 _21
	// l3:0 1 2 3 ... 63 _85
	// l4:0 1 2 3 ... 255 
	// l5:0 1 2 3 ... 1023
	public boolean register(Item item){
		RectF rect = item.getRect();
		int mnumLT = GetMortonNumber(rect.left, rect.top);
		int mnumRB = GetMortonNumber(rect.right, rect.bottom);
		
		Lg.i(TAG, "l t r b "+rect.left+"|"+rect.top+"|"+rect.right+"|"+rect.bottom);
		Lg.i(TAG, "mnumLT " + mnumLT + " mnumRB "+ mnumRB);
		
		int def = mnumLT^mnumRB;
		int pl = 0;
		int i;
		for(i=0;i<MAX_LEVEL;i++){
			int check = (def>>(i*2)) & 0x03;
			if (check != 0){
				pl = i+1;
			}
		}
		
		int space = mnumRB >> (pl*2);
		int offset = (mPow4[MAX_LEVEL-pl]-1)/3;
		Lg.i(TAG, "space " + space +" offset " + offset);
		space += offset;
	
		if(mTree[space] == null){
			// create new cell
			mTree[space] = new Cell(space);
		} 
		
		if(item.mObjectTree.getCell() == null){
			item.mObjectTree.setCell(mTree[space]);
			mTree[space].add(item.mObjectTree);
		} else {
			if(item.mObjectTree.getCell().getId() != space)
			{
				unregister(item);
				item.mObjectTree.setCell(mTree[space]);
				mTree[space].add(item.mObjectTree);
			}
			
		}
		
		return false;
	}
	
	public void unregister(Item i){
		Cell c =i.mObjectTree.getCell();
		c.remove(i.mObjectTree);
		
	}
	
	public List<ObjectTree> getCollisionList(int level, int mnum){
		ArrayList<ObjectTree> cl = new ArrayList<ObjectTree>();
		int i,p;
		for(i=level; i>0; i--){
			p = getParentMnum(mnum);
			Cell c = getCellByMnum(i, p);
			if(c == null) {
				mnum = p;
				continue;
			}
			List<ObjectTree> otl = c.getObjectTreeList();
			Lg.i(TAG, "level mnum  object = " +i+" "+p+" "+ otl.size());
			Iterator ite = otl.iterator();
			while(ite.hasNext()){
				ObjectTree ot = (ObjectTree)ite.next();
				cl.add(ot);
			}
		}
		
		return cl;
	}
	
	public Cell getCellByMnum(int level, int mnum){
		int index = (mPow4[level]-1)/3 + mnum;
		Lg.w(TAG, "l = " +level+" m = "+mnum+" inx = "+ index);
		return mTree[index];
	}
	
	public int getParentMnum(int mnum)	{
		/*
		Lg.i(TAG, "mnum "+mnum+" level "+level);
		Lg.i(TAG, "0 " +(mnum & 0b11));
		Lg.i(TAG, "2 " +((mnum >> 2) & 0b11));
		Lg.i(TAG, "4 " +((mnum >> 4) & 0b11));
		Lg.i(TAG, "6 " +((mnum >> 6) & 0b11));
		Lg.i(TAG, "8 " +((mnum >> 8) & 0b11));
		Lg.i(TAG, "10 " +((mnum >>10) & 0b11));
		*/
		/*
		int[] l = new int[level];
		l[3] = mnum & 0b11;
		l[2] = (mnum>>2) & 0b11;
		l[1] = (mnum>>2) & 0b11;
		l[0] = (mnum>>2) & 0b11;
		*/
		
		int p = (mnum-1)/4;
		Lg.i(TAG, "parent " + p);
		/*
		int pp = (p-1)/4;
		Lg.i(TAG, "pp "+pp);
		
		int ppp = (pp-1)/4;
		Lg.i(TAG, "ppp "+ppp);
		*/
		return p;
	}
	
	public short BitSpeparate(short n){
		n = (short)((n | (n<<8)) & 0x00ff00ff);
		n = (short)((n | (n<<4)) & 0x0f0f0f0f);
		n = (short)((n | (n<<2)) & 0x33333333);
		return (short)((n | (n<<1)) & 0x55555555);
	}
	
	public short GetMortonNumber(float x, float y){
		short xnum = (short)(x/mUnitW);
		short ynum = (short)(y/mUnitH);
		return (short)(BitSpeparate(xnum) | (BitSpeparate(ynum)<<1));
	}
	
	
}


