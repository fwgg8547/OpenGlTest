package com.fwgg8547.opentest;

import java.util.List;
import java.util.ArrayList;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.ScheduledFuture;

import android.content.*;
import android.opengl.GLSurfaceView;
import java.util.*;

public class GLEngine implements ScreenModel.Callback
{
	private static final String TAG = "GLEngine";
	public static final long FRAME_RATE = 60;
	public static final long FRATE_PRIOD_MS = 1000/FRAME_RATE;
	private static final int MAX_OBJECT = 10;		
	
	private Context mContext;
	private GLController mController;
	private List<SpriteModel> mModelList;
	private ModelGroup mModelGroup;
	private TreeManager mCollistionTree;
	private GlSurf mSurfaceView;
	private PriodWork mPriodWork;
	private ScheduledExecutorService mSchedular;
	private ScheduledFuture<?> mFuture;
	
	private class PriodWork implements Runnable
	{
		private boolean mIsFirst = true;
		
		@Override
		public void run()
		{
			onUpdate(mIsFirst);
			mIsFirst = false;
		}
	}
	
	public GLEngine(Context ctx) 
	{
		mContext = ctx;
		
	}

	public void initialize()
	{
		createModels();
		createController();
		createSurfaceView();
		
		ScreenModel.getInstance().setCallback(this);
		
		mSchedular = Executors.newSingleThreadScheduledExecutor();
		mPriodWork = new PriodWork();
		
	}
	
	public void finalize(){
		mSchedular.shutdownNow();
	}

	public GLSurfaceView getSurfaceView() 
	{
		return mSurfaceView;
	}

	public void start() {
		mFuture = mSchedular.scheduleAtFixedRate(mPriodWork, 0, FRATE_PRIOD_MS, TimeUnit.MILLISECONDS);
	}
	
	public void stop() {
		if(mFuture != null){
			mFuture.cancel(true);
		}
	}
	
	@Override
	public void onScreenChange(){
		boolean b = mCollistionTree.initialize(ScreenModel.getInstance().getScreenInfo());

		if(b){
			Iterator it = mModelList.iterator();
			while(it.hasNext()){
				SpriteModel m = (SpriteModel)it.next();
				mCollistionTree.registModel(m);
			}
		}
	}
	
	private void onUpdate(boolean isFirst){
		updateModel();
		updateControl();
	}
	
	private void updateModel(){
		Iterator it = mModelList.iterator();
		while(it.hasNext()){
			SpriteModel m = (SpriteModel)it.next();
			m.onUpdate();
		}
	}
	
	private void updateControl(){
		mController.onUpdate();
	}
	
	private void createModels()
	{
		mModelList = new ArrayList<SpriteModel>();
		mModelGroup = new ModelGroup();
		mCollistionTree = new TreeManager();
		
		// index 0: boll
		SpriteModel bm = new BlockModel();
		bm.initialize(mCollistionTree, 0, 1, mModelGroup);
		mModelList.add(bm);
		
		// index 1: enemy
		bm = new BlockModel2();
		bm.initialize(mCollistionTree, 10, 5, mModelGroup);
		mModelList.add(bm);
	}

	private void createController()
	{
		mController = new GLController(mContext);
		mController.addBollModel(mModelList.get(0));
		mController.addEnemyModel(mModelList.get(1));
		mController.addModelGroup(mModelGroup);
	}

	private void createSurfaceView()
	{
		mSurfaceView = new GlSurf(mContext, mModelList);
		mSurfaceView.setCallback(mController);
	}

}
