package com.fwgg8547.opentest;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;

import java.util.List;
import java.util.ArrayList;

import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.egl.EGLConfig;
import android.content.Context;
import android.opengl.GLES20;
import android.opengl.GLSurfaceView.Renderer;
import android.opengl.GLUtils;
import android.opengl.Matrix;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.view.MotionEvent;
import java.util.ArrayList;
import android.util.*;
import java.util.*;

public class GLRenderer implements Renderer
{
	private final static String TAG = "GLRenderer";
	private final float[] mtrxProjection = new float[16];
	private final float[] mtrxView = new float[16];
	private final float[] mtrxProjectionAndView = new float[16];
	private float[] mtrxTrans = new float[16];
	
	private RoadModel mRoad;

	// Geometric variables
	public static ArrayList<Float> verts;
	public static float vertices[];
	//public static short indices[];
	public static float uvs[];
	public FloatBuffer vertexBuffer;
	public ShortBuffer drawListBuffer;
	public FloatBuffer uvBuffer;

	public int indexCount;
	public TextManager tm;
	
	public Rect image;
	
	// Our screenresolution
	float   mScreenWidth = 1280;
	float   mScreenHeight = 768;

	// Misc
	Context mContext;
	long mLastTime;
	int mProgram;
	
	int mPos;
	private int mDelta;
	private int mMoveType = 0;
	private int mDeg = 0;
	private static final int SPNUM = 10;

	private final static long FPS = 30;
	private final static long FRAME_TIME = 1000/FPS;
	
	private FpsController mFpsCnt;
	
	public GLRenderer(Context c)
	{
		mPos = 0;
		mDelta = 5;
		mContext = c;
		mLastTime = System.currentTimeMillis() + 100;
		mRoad = RoadModel.getInstance();
		mRoad.initialize(10);
		mFpsCnt =new FpsController();
	}

	public void onPause()
	{
		/* Do stuff to pause the renderer */
	}

	public void onResume()
	{
		/* Do stuff to resume the renderer */
		mLastTime = System.currentTimeMillis();
	}

	@Override
	public void onDrawFrame(GL10 unused) {

		boolean isUpdated = mFpsCnt.onUpdate();
		
		// Render our example
		Render(mtrxProjectionAndView);
		UpdateSprite();

		// Render the text
		if(tm!=null) {
			if (isUpdated){
				tm.removeText();
				float f = mFpsCnt.getFps();
				TextObject to = new TextObject("f:"+f,10,10);
				tm.addText(to);
				tm.PrepareDraw();
			}
			tm.Draw(mtrxProjectionAndView);
			}
	}

	private void Render(float[] m) {

		// Set our shaderprogram to image shader
		GLES20.glUseProgram(riGraphicTools.sp_Image);
		
		// clear Screen and Depth Buffer, 
		// we have set the clear color as black.
		GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);

		// get handle to vertex shader's vPosition member
		int mPositionHandle = 
			GLES20.glGetAttribLocation(riGraphicTools.sp_Image, "vPosition");

		// Enable generic vertex attribute array
		GLES20.glEnableVertexAttribArray(mPositionHandle);

		// Prepare the triangle coordinate data
		GLES20.glVertexAttribPointer(mPositionHandle, 3,
                                 GLES20.GL_FLOAT, false,
                                 0, vertexBuffer);

		// Get handle to texture coordinates location
		int mTexCoordLoc = GLES20.glGetAttribLocation(riGraphicTools.sp_Image, 
																									"a_texCoord" );

		// Enable generic vertex attribute array
		GLES20.glEnableVertexAttribArray ( mTexCoordLoc );

		// Prepare the texturecoordinates
		GLES20.glVertexAttribPointer ( mTexCoordLoc, 2, GLES20.GL_FLOAT,
																	false,
																	0, uvBuffer);

		// Get handle to shape's transformation matrix
		int mtrxhandle = GLES20.glGetUniformLocation(riGraphicTools.sp_Image, 
																								 "uMVPMatrix");

		// Apply the projection and view transformation
		GLES20.glUniformMatrix4fv(mtrxhandle, 1, false, m, 0);

		// Get handle to textures locations
		int mSamplerLoc = GLES20.glGetUniformLocation (riGraphicTools.sp_Image, 
																									 "s_texture" );

		// Set the sampler texture unit to 0, where we have saved the texture.
		GLES20.glUniform1i ( mSamplerLoc, 0);

		GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA);
		GLES20.glEnable(GLES20.GL_BLEND);
		
		// Draw the triangle
		
		GLES20.glDrawElements(GLES20.GL_TRIANGLES, indexCount,
													GLES20.GL_UNSIGNED_SHORT, drawListBuffer);

		// Disable vertex array
		GLES20.glDisableVertexAttribArray(mPositionHandle);
		GLES20.glDisableVertexAttribArray(mTexCoordLoc);
	
	}

	@Override
	public void onSurfaceChanged(GL10 gl, int width, int height) {

		// We need to know the current width and height.
		mScreenWidth = width;
		mScreenHeight = height;

		// Redo the Viewport, making it fullscreen.
		GLES20.glViewport(0, 0, (int)mScreenWidth, (int)mScreenHeight);

		// Clear our matrices
		for(int i=0;i<16;i++)
		{
			mtrxProjection[i] = 0.0f;
			mtrxView[i] = 0.0f;
			mtrxProjectionAndView[i] = 0.0f;
		}

		// Setup our screen width and height for normal sprite translation.
		Matrix.orthoM(mtrxProjection, 0, 
		0.0f, mScreenWidth, 
		0.0f, mScreenHeight, 
		0.0f, 50.0f);

		// Set the camera position (View matrix)
		Matrix.setLookAtM(mtrxView, 0, 
		0f, 0f, 10f, // position of camera
		0f, 0.0f, 0f,  // position of view
		0f, 1.0f, 0.0f
		);

		// Calculate the projection and view transformation
		Matrix.multiplyMM(mtrxProjectionAndView, 0, mtrxProjection, 0, mtrxView, 0);

	}

	@Override
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {

		// Create the triangle
		SetupSprites();
		SetupImage();
		// Create our texts
		SetupText();
		
		// Set the clear color to black
		GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1);

		// Create the shaders, images
		int vertexShader = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Image);
		int fragmentShader = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Image);
		riGraphicTools.sp_Image = GLES20.glCreateProgram();     
		GLES20.glAttachShader(riGraphicTools.sp_Image, vertexShader);   
		GLES20.glAttachShader(riGraphicTools.sp_Image, fragmentShader);
		GLES20.glLinkProgram(riGraphicTools.sp_Image);

	
		
		// Text shader
		int vshadert = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Text);
		int fshadert = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Text);
		riGraphicTools.sp_Text = GLES20.glCreateProgram();
		GLES20.glAttachShader(riGraphicTools.sp_Text, vshadert);
		GLES20.glAttachShader(riGraphicTools.sp_Text, fshadert); 
		GLES20.glLinkProgram(riGraphicTools.sp_Text);

		
		// Set our shader programm
		GLES20.glUseProgram(riGraphicTools.sp_Image);
		
	}

	public void processTouchEvent(MotionEvent event)
	{
		if(event.getAction() == MotionEvent.ACTION_DOWN){
			float tx = event.getX() ;
			float ty = mScreenHeight - event.getY();
			Lg.i(TAG, "touch x"+tx + " y "+ty);
			
			if(mRoad.conflict(tx, ty)){
				Lg.i(TAG, "hit");
				mRoad.delete();
			} else{
				mMoveType = (mMoveType == 0)? 1:0;
				mDelta = mDelta * -1;
			}
		}
		//sprite[1].translate();
		/*
		// Get the half of screen value
		int screenhalf = (int) (mScreenWidth / 2);
		int screenheightpart = (int) (mScreenHeight / 3);
		if(event.getX()<screenhalf)
		{
			// Left screen touch
			if(event.getY() < screenheightpart)
				sprite.scale(-0.01f);
			else if(event.getY() < (screenheightpart*2))
				sprite.translate(-10f, -10f);
			else
				sprite.rotate(0.01f);
		}
		else
		{
			// Right screen touch
			if(event.getY() < screenheightpart)
				sprite.scale(0.01f);
			else if(event.getY() < (screenheightpart*2))
				sprite.translate(10f, 10f);
			else
				sprite.rotate(-0.01f);
		}
		*/
	}
	
	public void UpdateSprite()
	{
		
		if(mMoveType == 0){
			mRoad.scrollup(mDelta);
			
		} else {
			mDeg++;
			mRoad.roll(100f, mDeg);
		}
		
		
		SetupSprites();
	}
	
	public void SetupSprites()
	{
		
		float[] a = mRoad.getRoadVert(SPNUM);
		short[] b = mRoad.getRoadIndex(SPNUM);
		
		// The vertex buffer.
		ByteBuffer bb = ByteBuffer.allocateDirect(a.length * 4);
		bb.order(ByteOrder.nativeOrder());
		vertexBuffer = bb.asFloatBuffer();
		vertexBuffer.put(a);
		vertexBuffer.position(0);

		// initialize byte buffer for the draw list
		ByteBuffer dlb = ByteBuffer.allocateDirect(b.length * 2);
		dlb.order(ByteOrder.nativeOrder());
		drawListBuffer = dlb.asShortBuffer();
		drawListBuffer.put(b);
		drawListBuffer.position(0);
		
	  indexCount = mRoad.mIndexCount;
	}
	
	public void SetupImage()
	{
		// Create our UV coordinates.
		uvs = RoadModel.getInstance().getUvs();

		// The texture buffer
		ByteBuffer bb = ByteBuffer.allocateDirect(uvs.length * 4);
		bb.order(ByteOrder.nativeOrder());
		uvBuffer = bb.asFloatBuffer();
		uvBuffer.put(uvs);
		uvBuffer.position(0);

		// Generate Textures, if more needed, alter these numbers.
		int[] texturenames = new int[2];
		GLES20.glGenTextures(2, texturenames, 0);

		// Retrieve our image from resources.
		int id = mContext.getResources().getIdentifier("drawable/ic_launcher", null, 
																									 mContext.getPackageName());

		// Temporary create a bitmap
		Bitmap bmp = BitmapFactory.decodeResource(mContext.getResources(), R.drawable.ic_launcher);//id);

		// Bind texture to texturename
		GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
		GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texturenames[0]);

		// Set filtering
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, 
													 GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, 
													 GLES20.GL_LINEAR);

		// Set wrapping mode
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, 
													 GLES20.GL_CLAMP_TO_EDGE);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, 
													 GLES20.GL_CLAMP_TO_EDGE);

		// Load the bitmap into the bound texture.
		GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0);

		// We are done using the bitmap so we should recycle it.
		bmp.recycle();

		// Again for the text texture
		id = mContext.getResources().getIdentifier("drawable/font", null, 
																							 mContext.getPackageName());
		bmp = BitmapFactory.decodeResource(mContext.getResources(), id);
		GLES20.glActiveTexture(GLES20.GL_TEXTURE0 + 1);
		GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, texturenames[1]);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, 
													 GLES20.GL_LINEAR);
		GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, 
													 GLES20.GL_LINEAR);
		GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bmp, 0);
		bmp.recycle();
	}
	
	public void SetupText()
	{
    // Create our text manager
    tm = new TextManager();

    // Tell our text manager to use index 1 of textures loaded
    tm.setTextureID(1);

    // Pass the uniform scale
    tm.setUniformscale(3.0f);

    // Create our new textobject
    TextObject txt = new TextObject("hello world", 10f, 10f);

    // Add it to our manager
    tm.addText(txt);

    // Prepare the text for rendering
    tm.PrepareDraw();
	}
	
	
	
	
}
