package com.fwgg8547.opentest;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;

import java.util.List;
import java.util.ArrayList;

import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.egl.EGLConfig;
import android.content.Context;
import android.opengl.GLES20;
import android.opengl.GLSurfaceView.Renderer;
import android.opengl.GLUtils;
import android.opengl.Matrix;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.view.MotionEvent;
import java.util.ArrayList;
import android.util.*;
import java.util.*;

public class GLRenderer implements Renderer
{
	private final static String TAG = "GLRenderer";
	private final float[] mtrxProjection = new float[16];
	private final float[] mtrxView = new float[16];
	private final float[] mtrxProjectionAndView = new float[16];
	
	// Geometric variables
	public int[] mTexturename;
	public TextManager tm;
	
	// Our screenresolution
	private float   mScreenWidth = 1280;
	private float   mScreenHeight = 768;

	// Misc
	Context mContext;

		// FPS
	long mLastTime;
	private final static long FPS = 30;
	private final static long FRAME_TIME = 1000/FPS;
	private FpsController mFpsCnt;

		//Layer
	private OpenglLayer mLayer;

	public GLRenderer(Context c)
	{
		mContext = c;
		mLastTime = System.currentTimeMillis() + 100;
		mFpsCnt =new FpsController();
		mLayer = new SpriteLayer(c);
	}

	public void onPause()
	{
		/* Do stuff to pause the renderer */
	}

	public void onResume()
	{
		/* Do stuff to resume the renderer */
		mLastTime = System.currentTimeMillis();
	}

	@Override
	public void onDrawFrame(GL10 unused) {

		boolean isUpdated = mFpsCnt.onUpdate();
		
		// Render our example
		mLayer.draw(mtrxProjectionAndView);
		mLayer.update();
		
		// Render the text
		if(tm!=null) {
			if (isUpdated){
				tm.removeText();
				float f = mFpsCnt.getFps();
				TextObject to = new TextObject("f:"+f,10,10);
				tm.addText(to);
				tm.PrepareDraw();
			}
			tm.Draw(mtrxProjectionAndView);
			}
	}

	
	@Override
	public void onSurfaceChanged(GL10 gl, int width, int height) {

		// We need to know the current width and height.
		mScreenWidth = width;
		mScreenHeight = height;

		// Redo the Viewport, making it fullscreen.
		GLES20.glViewport(0, 0, (int)mScreenWidth, (int)mScreenHeight);

		// Clear our matrices
		for(int i=0;i<16;i++)
		{
			mtrxProjection[i] = 0.0f;
			mtrxView[i] = 0.0f;
			mtrxProjectionAndView[i] = 0.0f;
		}

		// Setup our screen width and height for normal sprite translation.
		Matrix.orthoM(mtrxProjection, 0, 
		0.0f, mScreenWidth, 
		0.0f, mScreenHeight, 
		0.0f, 50.0f);

		// Set the camera position (View matrix)
		Matrix.setLookAtM(mtrxView, 0, 
		0f, 0f, 10f, // position of camera
		0f, 0.0f, 0f,  // position of view
		0f, 1.0f, 0.0f
		);

		// Calculate the projection and view transformation
		Matrix.multiplyMM(mtrxProjectionAndView, 0, mtrxProjection, 0, mtrxView, 0);

	}

	@Override
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {
		// Create our texts
		SetupText();
		mLayer.setupPoints();
		setupTexture();
		
		
		// Set the clear color to black
		GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1);

		// Create the shaders, images
		int vertexShader = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Image);
		int fragmentShader = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Image);
		riGraphicTools.sp_Image = GLES20.glCreateProgram();     
		GLES20.glAttachShader(riGraphicTools.sp_Image, vertexShader);   
		GLES20.glAttachShader(riGraphicTools.sp_Image, fragmentShader);
		GLES20.glLinkProgram(riGraphicTools.sp_Image);

		// Text shader
		int vshadert = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Text);
		int fshadert = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Text);
		riGraphicTools.sp_Text = GLES20.glCreateProgram();
		GLES20.glAttachShader(riGraphicTools.sp_Text, vshadert);
		GLES20.glAttachShader(riGraphicTools.sp_Text, fshadert); 
		GLES20.glLinkProgram(riGraphicTools.sp_Text);

		// Set our shader programm
		GLES20.glUseProgram(riGraphicTools.sp_Image);
		
	}

	public void processTouchEvent(MotionEvent event)
	{
	}
	
	public void UpdateSprite()
	{
		mLayer.update();
	}
	
	public void setupTexture(){
		// Generate Textures, if more needed, alter these numbers.
		mTexturename = new int[2];
		GLES20.glGenTextures(2, mTexturename, 0);
		mLayer.setupTexture(GLES20.GL_TEXTURE0, mTexturename[0]);
		tm.setupTexture(GLES20.GL_TEXTURE0+1, mTexturename[1]);
	}
	
	public void SetupText()
	{
    // Create our text manager
    tm = new TextManager(mContext);
    // Pass the uniform scale
    tm.setUniformscale(3.0f);
	}
	
}
