package com.fwgg8547.opentest;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.ShortBuffer;

import java.util.List;
import java.util.ArrayList;

import javax.microedition.khronos.opengles.GL10;
import javax.microedition.khronos.egl.EGLConfig;
import android.content.Context;
import android.opengl.GLES20;
import android.opengl.GLSurfaceView.Renderer;
import android.opengl.GLUtils;
import android.opengl.Matrix;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Rect;
import android.view.MotionEvent;
import java.util.ArrayList;
import android.util.*;
import java.util.*;

public class GLRenderer implements Renderer
{
	private final static String TAG = "GLRenderer";
	private final float[] mtrxProjection = new float[16];
	private final float[] mtrxView = new float[16];
	private final float[] mtrxProjectionAndView = new float[16];
	
	// Geometric variables
	public int[] mTexturename;
	public TextManager tm;
	
	// Our screenresolution
	private float   mScreenWidth = 1280;
	private float   mScreenHeight = 768;

	// Misc
	Context mContext;

	// FPS
	long mLastTime;
	//private final static long FPS = 30;
	//private final static long FRAME_TIME = 1000/FPS;
	private FpsController mFpsCnt;
	
	//Layer
	private List<OpenglLayer> mLayers;

	public GLRenderer(Context c, List<SpriteModel> models)
	{
		mContext = c;
		mLastTime = System.currentTimeMillis() + 100;
		mFpsCnt =new FpsController();
		mLayers = new ArrayList<OpenglLayer>();
		
		Iterator it = models.iterator();
		while(it.hasNext()){
			OpenglLayer l = new SpriteLayer(c);
			SpriteModel m = (SpriteModel)it.next();
			l.setModels(m);
			mLayers.add(l);
		}
	}

	public void onPause()
	{
		/* Do stuff to pause the renderer */
	}

	public void onResume()
	{
		/* Do stuff to resume the renderer */
		mLastTime = System.currentTimeMillis();
	}

	@Override
	public void onDrawFrame(GL10 unused) {
		boolean isUpdated = mFpsCnt.onUpdate();
		
		GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
		// Render our example
		Iterator it = mLayers.iterator();
		while(it.hasNext()){
			OpenglLayer l = (OpenglLayer)it.next();
			l.draw(mtrxProjectionAndView);
			l.update();
		}
		
		
		// Render the text
		
		if(tm!=null) {
			if (isUpdated){
				tm.removeText();
				float f = mFpsCnt.getFps();
				int t = FpsController.mTestCounrt -60;
				FpsController.mTestCounrt=0;
				TextObject to = new TextObject("f:"+f+"|"+t ,10,10);
				tm.addText(to);
				tm.PrepareDraw();
			}
			tm.Draw(mtrxProjectionAndView);
		}
		
	}

	
	@Override
	public void onSurfaceChanged(GL10 gl, int width, int height) {

		// We need to know the current width and height.
		mScreenWidth = width;
		mScreenHeight = height;
		
		ScreenModel sm = ScreenModel.getInstance();
		sm.setScreenInfo(width, height);

		// Redo the Viewport, making it fullscreen.
		GLES20.glViewport(0, 0, (int)mScreenWidth, (int)mScreenHeight);

		// Clear our matrices
		for(int i=0;i<16;i++)
		{
			mtrxProjection[i] = 0.0f;
			mtrxView[i] = 0.0f;
			mtrxProjectionAndView[i] = 0.0f;
		}

		// Setup our screen width and height for normal sprite translation.
		Matrix.orthoM(mtrxProjection, 0, 
		0.0f, mScreenWidth, 
		0.0f, mScreenHeight, 
		0.0f, 50.0f);

		// Set the camera position (View matrix)
		Matrix.setLookAtM(mtrxView, 0, 
		0f, 0f, 10f, // position of camera
		0f, 0.0f, 0f,  // position of view
		0f, 1.0f, 0.0f
		);

		// Calculate the projection and view transformation
		Matrix.multiplyMM(mtrxProjectionAndView, 0, mtrxProjection, 0, mtrxView, 0);

	}

	@Override
	public void onSurfaceCreated(GL10 gl, EGLConfig config) {
		// Create our texts
		SetupText();
		Iterator it = mLayers.iterator();
		while(it.hasNext()){
			OpenglLayer l = (OpenglLayer)it.next();
			l.setupPoints();
		}
		setupTexture();
		
		
		// Set the clear color to black
		GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1);

		// Create the shaders, images
		int vertexShader = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Image);
		int fragmentShader = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Image);
		riGraphicTools.sp_Image = GLES20.glCreateProgram();     
		GLES20.glAttachShader(riGraphicTools.sp_Image, vertexShader);   
		GLES20.glAttachShader(riGraphicTools.sp_Image, fragmentShader);
		GLES20.glLinkProgram(riGraphicTools.sp_Image);

		// Text shader
		int vshadert = riGraphicTools.loadShader(GLES20.GL_VERTEX_SHADER, 
		riGraphicTools.vs_Text);
		int fshadert = riGraphicTools.loadShader(GLES20.GL_FRAGMENT_SHADER, 
		riGraphicTools.fs_Text);
		riGraphicTools.sp_Text = GLES20.glCreateProgram();
		GLES20.glAttachShader(riGraphicTools.sp_Text, vshadert);
		GLES20.glAttachShader(riGraphicTools.sp_Text, fshadert); 
		GLES20.glLinkProgram(riGraphicTools.sp_Text);

		// Set our shader programm
		GLES20.glUseProgram(riGraphicTools.sp_Image);
		
	}

	public void processTouchEvent(MotionEvent event)
	{
	}
	
	public void UpdateSprite()
	{
		Iterator it = mLayers.iterator();
		while(it.hasNext()){
			OpenglLayer l = (OpenglLayer) it.next();
			l.update();
		}
		
	}
	
	public void setupTexture(){
		// Generate Textures, if more needed, alter these numbers.
		mTexturename = new int[3];
		Lg.w(TAG,"gltex "+ GLES20.GL_TEXTURE0);
		GLES20.glGenTextures(3, mTexturename, 0);
		
		int i = 0;
		Iterator it = mLayers.iterator();
		while(it.hasNext()){
			OpenglLayer l = (OpenglLayer)it.next();
			l.setupTexture(GLES20.GL_TEXTURE0 + i, mTexturename[i], i);
			i++;
		}
		
		tm.setupTexture(GLES20.GL_TEXTURE0+i, mTexturename[i], i);
	}
	
	public void SetupText()
	{
    // Create our text manager
    tm = new TextManager(mContext);
    // Pass the uniform scale
    tm.setUniformscale(3.0f);
	}
	
}
