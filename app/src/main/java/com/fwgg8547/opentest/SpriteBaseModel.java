package com.fwgg8547.opentest;

import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

abstract public class SpriteBaseModel implements SpriteModel
{
	private static final String TAG = "SpriteBaseModel";
	protected List<Item> mBlocks;
	protected HashMap<Integer, Item> mDeletedItemMap;
	protected Integer[] mDeletedIndex;
	protected ModelGroup mGroup;
	protected int mIndexCount;
	protected TreeManager mCollisionTree;
	protected final ReadersWriterLock mLock = new ReadersWriterLock();
	
	
	
	public SpriteBaseModel() 
	{}
	
	@Override
	public Iterator iterator()
	{
		return mBlocks.iterator();
	}
	
	public int getIndexCount(){
		return mIndexCount;
	}
	
	public List<Item> getCollisionList(int level, float x, float y) {
		return mCollisionTree.getCollisionList(level, x, y);
	}
	
	public List<Item> getCollisionList(int level, int mnum){
		return mCollisionTree.getCollisionList(level, mnum);
	}	

	public List<Item> getCollisionList(Item itm){
		return mCollisionTree.getCollisionList(itm);
	}	
	
	public List<Item> getCollisionList(SpriteModel m){
	
		List<Item> cl = null;
		Iterator it = m.iterator();
		while(it.hasNext()){
		  Item itm = (Item)it.next();
			if(cl == null){
				cl = mCollisionTree.getCollisionList(itm);
			} else {
				
			}
		}

		return cl;
	}	
	
	public void refreshTree(List<Item> cl) {
		mCollisionTree.refreshTree(cl);
	}

	@Override
	public void refreshTree(Item i)
	{
		mCollisionTree.refreshTree(i);
	}
	
	@Override
	public void refreshTree()
	{
		refreshTree(mBlocks);
	}
	
	@Override
	public ItemData getData(){
		ItemData id = new ItemData();
		try{
			mLock.readLock();
			float[] def = new float[] {
				0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
			};
			
			int i = 0;
			for(int j=0, n=mBlocks.size();j<n;j++){
				Item itm = mBlocks.get(j);
				if(!itm.mIsDeleted){
					if(id.mVert == null) {
						id.mVert = itm.getSprite().getTransformedVertices();
					} else {
						id.mVert = floatArrayConcat(id.mVert, itm.getSprite().getTransformedVertices());
					}
					
					if(id.mIndex == null) {
						id.mIndex = itm.getSprite().getIndices(i);
					} else {
						id.mIndex = shortArrayConcat(id.mIndex, itm.getSprite().getIndices(i));
					}
					
					if(id.mUv == null){
						id.mUv = def;
					} else {
						id.mUv = floatArrayConcat(id.mUv, def);
					}
					
					i++;
				}
			}
			
			mIndexCount = id.mIndex.length;
		} catch (Exception InterruptedException){
			
		} finally {
			mLock.readUnlock();
		}
		
		
		return id;
	}
	
	public float[] getVert(int length){
		float[] vert = null;
		
		try {
			mLock.readLock();
			int i = 1;
		
			for(int j=0, n=mBlocks.size();j<n;j++){
				Item itm = mBlocks.get(j);
				if(!itm.mIsDeleted){
					if(vert == null) {
						vert = itm.getSprite().getTransformedVertices();
					} else {
						vert = floatArrayConcat(vert, itm.getSprite().getTransformedVertices());
					}
					
					
					if(i >= length){
						break;
					} else {
						i++;
					}
				}
			}
			
			
			
			

		} catch(Exception InterruptedException){
			
		} finally{
			mLock.readUnlock();
			return vert;
		}
	}

	public short[] getIndex(int length){
		short[] index = null;
		
		try{
			mLock.readLock();
			
			int i = 0;
		
			for(int j=0,n=mBlocks.size();j<n;j++){
				Item it =mBlocks.get(j);
				if(!it.mIsDeleted){
					if(index == null) {
						index = it.getSprite().getIndices(i);
					} else {
						index = shortArrayConcat(index, it.getSprite().getIndices(i));
					}

					if(i+1 >= length){
						break;
					} else {
						i++;
					}
				}
			}

			mIndexCount = index.length;
				
		} catch(Exception InterruptedException){
			
		} finally{
			mLock.readUnlock();
			return index;
		}
	}

	public float[] getUvs(){
		float[] ux = null;
		try {
			mLock.readLock();
		
			float[] def = new float[] {
				0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
			};

			for(int i=0; i<mBlocks.size();i++){
				Item it = mBlocks.get(i);
				if(it.mIsDeleted){
					continue;
				}
				if(ux == null){
					ux = def;
				} else {
					ux = floatArrayConcat(ux, def);
				}
			}
		
		} catch(Exception InterruptedException){
			
		} finally {

			mLock.readUnlock();
			return ux;
		}
	}

	private float[] floatArrayConcat(float[] a, float[] b){
		float res[] = new float[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}

	private short[] shortArrayConcat(short[] a, short[] b){
		short res[] = new short[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}
	
}
