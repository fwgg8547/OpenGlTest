package com.fwgg8547.opentest;

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

abstract public class SpriteBaseModel implements SpriteModel
{
	private static final String TAG = "SpriteBaseModel";
	protected List<Item> mBlocks;
	protected ModelGroup mGroup;
	protected int mIndexCount;
	
	@Override
	public Iterator iterator()
	{
		return mBlocks.iterator();
	}

	public int getIndexCount(){
		return mIndexCount;
	}

	abstract public void initialize(int num, ModelGroup mg);

	synchronized public boolean conflict(float x, float y){
		boolean isConflict = false;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.getSprite().conflict2(x, y)){
				Lg.i(TAG, "hit " +i.mId);
				i.mIsConflict = true;
				isConflict = true;
			}
		}
		return isConflict;
	}

	public boolean conflict(float x, float y, List<Item> cl){
		boolean isConflict = false;

		Iterator it = cl.iterator();
		while(it.hasNext()){
			Item i = (Item)it.next();
			if(i.getSprite().conflict2(x, y)){
				Lg.i(TAG, "hit " +i.mId);
				i.mIsConflict = true;
				isConflict = true;
			}
		}

		return isConflict;
	}

  public int getIndexOfConflict() 
	{
		boolean hit = false;
		int index = -1;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.mIsConflict)
			{
				hit = true;
				break;
			}
			else 
			{
				index++;
			}
		}
		return (hit)? index: -1 ;
	}

	public float[] getVert(int length){
		int i = 1;
		float[] vert = null;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(vert == null) {
				vert = it.getSprite().getTransformedVertices();
			} else {
				vert = floatArrayConcat(vert, it.getSprite().getTransformedVertices());
			}
			if(i >= length){
				break;
			} else {
				i++;
			}
		}
		return vert;
	}

	public short[] getIndex(int length){
		int i = 0;
		short[] index = null;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(index == null) {
				index = it.getSprite().getIndices(i);
			} else {
				index = shortArrayConcat(index, it.getSprite().getIndices(i));
			}

			if(i+1 >= length){
				break;
			} else {
				i++;
			}
		}
		mIndexCount = index.length;
		return index;
	}

	public float[] getUvs(){
		float[] def = new float[] {
			0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
		};

		float[] ux = null;
		for(int i=0; i<mBlocks.size();i++){

			if(ux == null){
				ux = def;
			} else {
				ux = floatArrayConcat(ux, def);
			}

		}

		return ux;
	}

	private float[] floatArrayConcat(float[] a, float[] b){
		float res[] = new float[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}

	private short[] shortArrayConcat(short[] a, short[] b){
		short res[] = new short[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}
	
}
