package com.fwgg8547.opentest;

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

abstract public class SpriteBaseModel implements SpriteModel
{
	private static final String TAG = "SpriteBaseModel";
	protected List<Item> mBlocks;
	protected ModelGroup mGroup;
	protected int mIndexCount;
	protected TreeManager mCollisionTree;
	protected final ReadersWriterLock mLock = new ReadersWriterLock();
	
	public SpriteBaseModel() 
	{}
	
	@Override
	public Iterator iterator()
	{
		return mBlocks.iterator();
	}

	public int getIndexCount(){
		return mIndexCount;
	}
	
	public List<Item> getCollisionList(int level, float x, float y) {
		return mCollisionTree.getCollisionList(level, x, y);
	}
	
	public List<Item> getCollisionList(int level, int mnum){
		return mCollisionTree.getCollisionList(level, mnum);
	}	

	public List<Item> getCollisionList(Item itm){
		return mCollisionTree.getCollisionList(itm);
	}	
	
	public List<Item> getCollisionList(SpriteModel m){
	
		List<Item> cl = null;
		Iterator it = m.iterator();
		while(it.hasNext()){
		  Item itm = (Item)it.next();
			if(cl == null){
				cl = mCollisionTree.getCollisionList(itm);
			} else {
				
			}
		}
		
		return cl;
	}	
	
	public void refreshTree(List<Item> cl) {
		mCollisionTree.refreshTree(cl);
	}

	@Override
	public void refreshTree(Item i)
	{
		mCollisionTree.refreshTree(i);
	}
	
	@Override
	public void refreshTree()
	{
		refreshTree(mBlocks);
	}
	
	
	public float[] getVert(int length){
		float[] vert = null;
		
		try {
			mLock.readLock();
			int i = 1;
		
			Iterator ite = mBlocks.iterator();
			while(ite.hasNext()){
				Item it =(Item)ite.next();
				if(vert == null) {
					vert = it.getSprite().getTransformedVertices();
				} else {
					vert = floatArrayConcat(vert, it.getSprite().getTransformedVertices());
				}
				if(i >= length){
					break;
				} else {
					i++;
				}
		}
		
		} catch(Exception InterruptedException){
			
		} finally{
			mLock.readUnlock();
			return vert;
		}
	}

	public short[] getIndex(int length){
		short[] index = null;
		
		try{
			mLock.readLock();
			
			int i = 0;
		
			Iterator ite = mBlocks.iterator();
			while(ite.hasNext()){
				Item it =(Item)ite.next();
				if(index == null) {
					index = it.getSprite().getIndices(i);
				} else {
					index = shortArrayConcat(index, it.getSprite().getIndices(i));
				}

				if(i+1 >= length){
					break;
				} else {
					i++;
				}
			}
				mIndexCount = index.length;
		} catch(Exception InterruptedException){
			
		} finally{
			mLock.readUnlock();
			return index;
		}
	}

	public float[] getUvs(){
		float[] ux = null;
		try {
			mLock.readLock();
		
			float[] def = new float[] {
				0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
			};

			for(int i=0; i<mBlocks.size();i++){

			if(ux == null){
				ux = def;
			} else {
				ux = floatArrayConcat(ux, def);
			}
		}
		
		} catch(Exception InterruptedException){
			
		} finally {

			mLock.readUnlock();
			return ux;
		}
	}

	private float[] floatArrayConcat(float[] a, float[] b){
		float res[] = new float[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}

	private short[] shortArrayConcat(short[] a, short[] b){
		short res[] = new short[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}
	
}
