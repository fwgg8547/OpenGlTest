package com.fwgg8547.opentest;
import android.graphics.*;
import android.animation.*;

public class Item
{
	public int mId;
	public int mGroupId;
	private Sprite mSprite;
	public boolean mIsDeleted;
	public boolean mIsConflict;
	private Cell mCell;
	private MoveType mMoveType;
	
	// current position
	private PointF mPosition;
	private float mR;
	private float mDeg;
	
	private MoveParam2 mAnim;

	public enum AnimType {
		ROLL,
		STRIGHT,
	}
	
	public class MoveParam{
		public float mx;
		public float my;
		public float mr;
		public float mdeg;
		
		public MoveParam(float x, float y, float r, float deg){
			mx = x;
			my = y;
			mr = r;
			mdeg = deg;
		}
		
		public void setParam(float x, float y, float r, float deg){
			mx = x;
			my = y;
			mr = r;
			mdeg = deg;
		}
	}
	
	public class MoveParam2{
		public float mex;
		public float mey;
		public float mer;
		public float medeg;
		public float mdtv;
		public float mdtdeg;
		public float mVerocity;
		public int mDuration;
		public Vec2 mDirect;
		public AnimType mType;
	
		public boolean mValid;
		
		public MoveParam2(){
			mex = 0.0f;
			mey = 0.0f;
			mer = 0.0f;
			medeg = 0.0f;
			mDirect = null;
			mVerocity = 0.0f;
			mDuration = 0;
			mValid = false;
		}

		public void setEndParam(float x, float y, float r, float deg){
			mex = x;
			mey = y;
			mer = r;
			medeg = deg;
		}

		public void setDirect(Vec2 d){
			mDirect = d;
		}
		
		public void setVerocity(float v){
			mVerocity = v;
			mdtv = v/100.0f;
			mdtdeg = v/100.0f;
		}
		
		public void setDuration(int d){
			mDuration = d;
		}
		
		public void setValid(boolean v){
			mValid = v;
		}
		
		public void setType(AnimType t){
			mType = t;
		}
	}
	
	public enum MoveType {
		NONE,
		STRIGHT,
		CIRCLE
	}
	
	public Item() 
	{
		mGroupId = 0;
		mIsDeleted = false;
		mIsConflict = false;
		mPosition = new PointF(0.0f, 0.0f);
		mR = 0.0f;
		mDeg = 0.0f;
		
		mMoveType = MoveType.NONE;
		mAnim = new MoveParam2(); 
	}
	
	public int getSpriteId(){
		return mSprite.getId();
	}
	
	public void setPosition(float x, float y, float r, float deg){
		mPosition.x = x;
		mPosition.y = y;
		mR = r;
		mDeg = deg;
		
		mSprite.translate(
			(float)(x + r*Math.cos(deg*Math.PI/180.0f)),
			(float)(y + r*Math.sin(deg*Math.PI/180.0f)));
	}
	
	public MoveParam getPosition(){
		return new MoveParam(
			mPosition.x,
			mPosition.y,
			mR,
			mDeg
		);
	}
	
	public void setAnimParam(
		AnimType t,
		float ex, float ey, float er, float edeg,
		float v,
		int d,
		Vec2 vd){
		//mAnim.setStartParam(sx,sy,sr,sdeg);
		mAnim.mType = t;
		mAnim.setEndParam(ex,ey,er,edeg);
		mAnim.setVerocity(v);
		mAnim.setDuration(d);
		mAnim.setDirect(vd);
	}
	
	public void setAnimationValid(boolean v){
		mAnim.setValid(v);
	}
	
	public void setMoveType(MoveType mt){
		mMoveType = mt;
	}
	
	public MoveType getType(){
		return mMoveType;
	}
	
	public void setSprite(Sprite s){
		mSprite = s;
	}
	
	public Sprite getSprite(){
		return mSprite;
	}
	
	public RectF getRect() {
		return mSprite.getOutline();
	}
	
	public void setCell(Cell c){
		mCell = c;
	}

	public Cell getCell(){
		return mCell;
	}
	
	public boolean isCollision(RectF r){
		return RectF.intersects(mSprite.getOutline() , r);
	}
	
	// ラジアン = 度 × 円周率 ÷ 180
	public void onMove(){
	}
	
	public void moveSingle(float x, float y){
		mSprite.translate(x,y);
	}
	
	public void moveRoll(float x, float y){
		mAnim.mValid = false;
		Vec2 v = new Vec2(x-mPosition.x, y-mPosition.y);
		float r = mR / Vec2.size(v);
		v.multiply(r);
		v.x += mPosition.x;
		v.y += mPosition.y;
		mSprite.translate(v);	
	}
	
	public void moveRoll(float dtdeg){
		mAnim.mValid = false;
		//RectF rect = mSprite.getOutline();
		//Vec2 v1 = new Vec2(rect.left, rect.top);
		//Vec2 v2 = new Vec2();
		mDeg += dtdeg;
		
		mSprite.translate((float)(mPosition.x +mR*Math.cos(mDeg*Math.PI/180.0)),
											(float)(mPosition.y + mR*Math.sin(mDeg*Math.PI/180.0)));
		
	}
	
	public PointF moveAnimation(){
		if(!mAnim.mValid || mAnim.mDuration <= 0) {
			mAnim.mValid = false;
			mAnim.mDuration = 0;
			return null;
		}
		
		PointF pos = null;
		mAnim.mDuration--;
		
		switch(mAnim.mType){
			case ROLL:
				pos = moveAnimation1();
				break;
			case STRIGHT:
				pos = moveAnimation2();
				break;
		}
		
		return pos;
	}
	
	public PointF moveAnimation1(){
		// roll scroll
		if(mAnim.mdtdeg > 0) {
			if(mDeg < mAnim.medeg){
				mDeg += mAnim.mdtdeg;
				mDeg = mDeg % 360;
				mAnim.mdtdeg -= mAnim.mdtdeg*0.1f;
				if (mAnim.mdtdeg <= 0) {
					// animation end by veromty is zero
					mAnim.mValid = false;
				}
			} else {
				// animation end by arrive end point
				//mAnim.mValid = false;
			}
		}	else {
			if(mDeg > -1.0f*mAnim.medeg){
				mDeg += mAnim.mdtdeg;
				mDeg = mDeg % 360;
				mAnim.mdtdeg -= mAnim.mdtdeg*0.1f;				
				if (mAnim.mdtdeg >= 0) {
					// animation end by verocity is zero
					mAnim.mValid = false;
				}		
			} else {
				// animation end by arrive end point
				// mAnim.mValid = false;				
			}
		}
		return mSprite.translate((float)(mPosition.x +mR*Math.cos(mDeg*Math.PI/180.0)),
											(float)(mPosition.y +mR*Math.sin(mDeg*Math.PI/180.0)));
											
		
	}
	
	public PointF moveAnimation2(){
		
		float ppf = mAnim.mVerocity/GLEngine.FRAME_RATE;
		Vec2 v = new Vec2(mAnim.mDirect.x, mAnim.mDirect.y);
		v.multiply(ppf);
		
		//float h = ScreenModel.getInstance().getHeight();
		RectF rect = ScreenModel.getInstance().getScreenInfo();
		if(mPosition.y +v.y > 0 && mPosition.y + v.y < rect.bottom){
			mPosition.y += v.y;
		}
		if(mPosition.x +v.x > 0 && mPosition.x + v.x < rect.right){
			mPosition.x += v.x;
		}
		
		return mSprite.translate(mPosition.x, mPosition.y);
	}
}
