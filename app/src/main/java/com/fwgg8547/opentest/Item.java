package com.fwgg8547.opentest;
import android.graphics.*;
import android.animation.*;

public class Item
{
	public int mId;
	public int mGroupId;
	private Sprite mSprite;
	public boolean mIsDeleted;
	public boolean mIsConflict;
	private Cell mCell;
	private MoveType mMoveType;
	
	// current position
	private PointF mPosition;
	private float mR;
	private float mDeg;
	
	private MoveParam2 mAnim;

	public class MoveParam{
		public float mx;
		public float my;
		public float mr;
		public float mdeg;
		
		public MoveParam(float x, float y, float r, float deg){
			mx = x;
			my = y;
			mr = r;
			mdeg = deg;
		}
		
		public void setParam(float x, float y, float r, float deg){
			mx = x;
			my = y;
			mr = r;
			mdeg = deg;
		}
	}
	
	public class MoveParam2{
		public float msx;
		public float msy;
		public float msr;
		public float msdeg;
		
		public float mex;
		public float mey;
		public float mer;
		public float medeg;
		
		public float mdtv;
		public float mdtdeg;
		
		public float mVerocity;

		public boolean mValid;
		
		public MoveParam2(){
			msx = 0.0f;
			msy = 0.0f;
			msr = 0.0f;
			msdeg = 0.0f;
			
			mex = 0.0f;
			mey = 0.0f;
			mer = 0.0f;
			medeg = 0.0f;
			
			mVerocity = 0.0f;
			
			mValid = false;
		}

		public void setEndParam(float x, float y, float r, float deg){
			mex = x;
			mey = y;
			mer = r;
			medeg = deg;
		}
		
		public void setStartParam(float x, float y, float r, float deg){
			msx = x;
			msy = y;
			msr = r;
			msdeg = deg;
		}
		
		public void setVerocity(float v){
			mVerocity = v;
			mdtv = v/100.0f;
			mdtdeg = v/100.0f;
			mValid = true;
		}
	}
	
	public enum MoveType {
		NONE,
		STRIGHT,
		CIRCLE
	}
	
	public Item() 
	{
		mGroupId = 0;
		mIsDeleted = false;
		mIsConflict = false;
		mPosition = new PointF(0.0f, 0.0f);
		mR = 0.0f;
		mDeg = 0.0f;
		
		mMoveType = MoveType.NONE;
		mAnim = new MoveParam2(); 
	}
	
	public int getSpriteId(){
		return mSprite.getId();
	}
	
	public void setPosition(float x, float y, float r, float deg){
		mPosition.x = x;
		mPosition.y = y;
		mR = r;
		mDeg = deg;
		
		mSprite.translate(
			(float)(x + r*Math.cos(deg*Math.PI/180.0f)),
			(float)(y + r*Math.sin(deg*Math.PI/180.0f)));
	}
	
	public MoveParam getPosition(){
		return new MoveParam(
			mPosition.x,
			mPosition.y,
			mR,
			mDeg
		);
	}
	
	public void setAnimParam(
		float sx, float sy, float sr, float sdeg, 
		float ex, float ey, float er, float edeg,
		float v){
		mAnim.setStartParam(sx,sy,sr,sdeg);
		mAnim.setEndParam(ex,ey,er,edeg);
		mAnim.setVerocity(v);
	}
	
	public void setMoveType(MoveType mt){
		mMoveType = mt;
	}
	
	public MoveType getType(){
		return mMoveType;
	}
	
	public void setSprite(Sprite s){
		mSprite = s;
	}
	
	public Sprite getSprite(){
		return mSprite;
	}
	
	public RectF getRect() {
		return mSprite.getOutline();
	}
	
	public void setCell(Cell c){
		mCell = c;
	}

	public Cell getCell(){
		return mCell;
	}
	
	// ラジアン = 度 × 円周率 ÷ 180
	public void onMove(){
	}
	
	public void moveSingle(float x, float y){
		mSprite.translate(x,y);
	}
	
	public void moveRoll(float x, float y){
		Vec2 v = new Vec2(x-mPosition.x, y-mPosition.y);
		float r = mR / Vec2.size(v);
		v.multiply(r);
		v.x += mPosition.x;
		v.y += mPosition.y;
		mSprite.translate(v);	
	}
	
	public void moveRoll(float dtdeg){
		//RectF rect = mSprite.getOutline();
		//Vec2 v1 = new Vec2(rect.left, rect.top);
		//Vec2 v2 = new Vec2();
		mDeg += dtdeg;
		
		mSprite.translate((float)(mPosition.x +mR*Math.cos(mDeg*Math.PI/180.0)),
											(float)(mPosition.y + mR*Math.sin(mDeg*Math.PI/180.0)));
		
	}
	
	public void moveAnimation(){
		if(!mAnim.mValid) {
			return;
		}
		
		if(mAnim.mdtdeg > 0) {
			if(mAnim.msdeg < mAnim.medeg){
				mAnim.msdeg += mAnim.mdtdeg;
				mAnim.mdtdeg -= mAnim.mdtdeg*0.1f;
				if (mAnim.mdtdeg <= 0) {
					// animation end by verocity is zero
					mAnim.mValid = false;
				}
			} else {
				// animation end by arrive end point
				//mAnim.mValid = false;
			}
		}	else {
			if(mAnim.msdeg > -1.0f*mAnim.medeg){
				mAnim.msdeg += mAnim.mdtdeg;
				mAnim.mdtdeg -= mAnim.mdtdeg*0.1f;				
				if (mAnim.mdtdeg >= 0) {
					// animation end by verocity is zero
					mAnim.mValid = false;
				}		
			} else {
				// animation end by arrive end point
				// mAnim.mValid = false;				
			}
		}
		mSprite.translate((float)(mPosition.x +mAnim.msr*Math.cos(mAnim.msdeg*Math.PI/180.0)),
											(float)(mPosition.y +mAnim.msr*Math.sin(mAnim.msdeg*Math.PI/180.0)));
	}
}
