package com.fwgg8547.opentest;

import android.graphics.RectF;
import android.graphics.PointF;

public class Sprite
{
	private static final String TAG = "Sprite";
	int id;
	float angle;
	float scale;
	RectF base;
	PointF translation;
	PointF tempPos;
	short[] indices;
	
	Vec2[] vector;

	public Sprite(int i)
	{
		id = i;

		// Initialise our intital size around the 0,0 point
		base = new RectF(-50f,50f, 50f, -50f);

		// Initial translation
		translation = new PointF(0f,0f);
		tempPos = new PointF(0f,0f);

		// We start with our inital size
		scale = 1f;

		// We start in our inital angle
		angle = 0f;
		
	}


	public boolean conflict2(float x, float y){
		boolean isConflict = false;
		float[] pos = getTransformedVertices();
		float left = pos[0];
		float top = pos[1];
		float right = pos[6];
		float bottom = pos[4];
		
		//Lg.w(TAG, "l t r b " + left+" "+top+" "+right+" "+bottom);
		if(left <= x && x <= right){
			if(bottom <= y && y <= top){
				isConflict = true;
			}
		}
		return isConflict;
	}
	
	public boolean conflict(float x, float y){
		boolean isConflict = true;
		Vec2Rect vr = getTransformedVector();
		
		int i = 0;
		for(Vec2 v: vr.vec){
			Vec2 p = new Vec2(x -vr.point[i].x, y- vr.point[i].y);
			if(Vec2.cross(v,p) < 0){
				//Lg.i(TAG, "cross < 0");
			} else{
				isConflict = false;
				//Lg.i(TAG, "out of sprote");
				break;
			}
			i++;
		}
		
		return isConflict;
	}
	
	public void translate(float deltax, float deltay)
	{
		// Update our location.
		translation.x = deltax;
		translation.y = deltay;
	}

	public void translateTemp(float dx, float dy){
		tempPos.x = dx;
		tempPos.y = dy;
	}
	
	public void translate(float deltay)
	{
		// Update our location.
		translation.y = deltay;
	}
	
	public float translateDelta(float deltay)
	{
		// Update our location.
		translation.y += deltay;
		return translation.y;
	}
	
	public float getPositionY(){
		return translation.y;
	}
	
	public void scale(float deltas)
	{
		scale = deltas;
	}

	public void rotate(float deltaa)
	{
		double rad = Math.PI * deltaa / 180.0f;
		angle += rad;
	}

	public short[] getIndices(int base){
		indices = new short[] {
			(short)(0+4*base), (short)(1+4*base), (short)(2+4*base),
			(short)(0+4*base), (short)(2+4*base), (short)(3+4*base)
		};
		return indices;
	}
	
	public Vec2Rect getTransformedVector()
	{
		// Start with scaling
		float x1 = base.left * scale;
		float x2 = base.right * scale;
		float y1 = base.bottom * scale;
		float y2 = base.top * scale;

		// We now detach from our Rect because when rotating, 
		// we need the seperate points, so we do so in opengl order
		PointF one = new PointF(x1, y2);
		PointF two = new PointF(x1, y1);
		PointF three = new PointF(x2, y1);
		PointF four = new PointF(x2, y2);

		// We create the sin and cos function once, 
		// so we do not have calculate them each time.
		float s = (float) Math.sin(angle);
		float c = (float) Math.cos(angle);

		// Then we rotate each point
		one.x = x1 * c - y2 * s;
		one.y = x1 * s + y2 * c;
		two.x = x1 * c - y1 * s;
		two.y = x1 * s + y1 * c;
		three.x = x2 * c - y1 * s;
		three.y = x2 * s + y1 * c;
		four.x = x2 * c - y2 * s;
		four.y = x2 * s + y2 * c;

		// Finally we translate the sprite to its correct position.
		one.x += translation.x;
		one.y += translation.y;
		two.x += translation.x;
		two.y += translation.y;
		three.x += translation.x;
		three.y += translation.y;
		four.x += translation.x;
		four.y += translation.y;

		one.x += tempPos.x;
		one.y += tempPos.y;
		two.x += tempPos.x;
		two.y += tempPos.y;
		three.x += tempPos.x;
		three.y += tempPos.y;
		four.x += tempPos.x;
		four.y += tempPos.y;

		return new Vec2Rect(one, two, three, four);
	}
	
	public float[] getTransformedVertices()
	{
		// Start with scaling
		float x1 = base.left * scale;
		float x2 = base.right * scale;
		float y1 = base.bottom * scale;
		float y2 = base.top * scale;

		// We now detach from our Rect because when rotating, 
		// we need the seperate points, so we do so in opengl order
		PointF one = new PointF(x1, y2);
		PointF two = new PointF(x1, y1);
		PointF three = new PointF(x2, y1);
		PointF four = new PointF(x2, y2);

		// We create the sin and cos function once, 
		// so we do not have calculate them each time.
		float s = (float) Math.sin(angle);
		float c = (float) Math.cos(angle);

		// Then we rotate each point
		one.x = x1 * c - y2 * s;
		one.y = x1 * s + y2 * c;
		two.x = x1 * c - y1 * s;
		two.y = x1 * s + y1 * c;
		three.x = x2 * c - y1 * s;
		three.y = x2 * s + y1 * c;
		four.x = x2 * c - y2 * s;
		four.y = x2 * s + y2 * c;

		// Finally we translate the sprite to its correct position.
		one.x += translation.x;
		one.y += translation.y;
		two.x += translation.x;
		two.y += translation.y;
		three.x += translation.x;
		three.y += translation.y;
		four.x += translation.x;
		four.y += translation.y;

		one.x += tempPos.x;
		one.y += tempPos.y;
		two.x += tempPos.x;
		two.y += tempPos.y;
		three.x += tempPos.x;
		three.y += tempPos.y;
		four.x += tempPos.x;
		four.y += tempPos.y;
		
		vector = new Vec2[] {
			new Vec2(one.x - two.x, one.y - two.y),
			new Vec2(two.x - three.x, two.y - three.y),
			new Vec2(three.x - four.x, three.y - four.y),
			new Vec2(four.x - one.x, four.y - one.y)
		};
		
		// We now return our float array of vertices.
		return new float[]
		{
			one.x, one.y, 0.0f,
			two.x, two.y, 0.0f,
			three.x, three.y, 0.0f,
			four.x, four.y, 0.0f,
		};
	}
}
