package com.fwgg8547.opentest;

import java.util.List;
import java.util.ArrayList;
import java.util.*;

public class BlockModel implements SpriteModel
{
	private static BlockModel instance;
	private List<Item> mBlocks;
	private int mIndexCount;
	
	public class Item {
		public int mId;
		public Sprite mSprite;
		public boolean mIsDeleted;
		public boolean mIsConflict;

		public Item() 
		{
			mIsDeleted = false;
			mIsConflict = false;
		}
	}
	
	public static BlockModel getInstance(){
		if(instance == null){
			instance = new BlockModel();
		}

		return instance;
	}

	private BlockModel(){
		mBlocks = new ArrayList<Item>();
	}
	
	public int getIndexCount(){
		return mIndexCount;
	}
	
	public void initialize(int num){
		for(int i=0; i<num; i++){
			Sprite s = new Sprite(i);
			Item it = new Item();
			it.mId = i;
			it.mSprite = s;
			mBlocks.add(it);
		}
	}

	synchronized public boolean conflict(float x, float y){
		boolean isConflict = false;

		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.mSprite.conflict(x, y)){
				Lg.i(TAG, "hit " +i.mId);
				i.mIsConflict = true;
				isConflict = true;
			}
		}
		return isConflict;
	}

  public int getIndexOfConflict() 
	{
		boolean hit = false;
		int index = -1;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item i = (Item)ite.next();
			if(i.mIsConflict)
			{
				hit = true;
				break;
			}
			else 
			{
				index++;
			}
		}
		return (hit)? index: -1 ;
	}
	
	public float[] getVert(int length){
		int i = 1;
		float[] vert = null;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(vert == null) {
				vert = it.mSprite.getTransformedVertices();
			} else {
				vert = floatArrayConcat(vert, it.mSprite.getTransformedVertices());
			}
			if(i >= length){
				break;
			} else {
				i++;
			}
		}
		return vert;
	}

	public short[] getIndex(int length){
		int i = 0;
		short[] index = null;
		Iterator ite = mBlocks.iterator();
		while(ite.hasNext()){
			Item it =(Item)ite.next();
			if(index == null) {
				index = it.mSprite.getIndices(i);
			} else {
				index = shortArrayConcat(index, it.mSprite.getIndices(i));
			}

			if(i+1 >= length){
				break;
			} else {
				i++;
			}
		}
		mIndexCount = index.length;
		return index;
	}
	
	public float[] getUvs(){
		float[] def = new float[] {
			0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f, 0.0f
		};
		
		float[] ux = null;
		for(int i=0; i<mBlocks.size();i++){
			
			if(ux == null){
				ux = def;
			} else {
				ux = floatArrayConcat(ux, def);
			}

		}
			
		return ux;
	}
	
	private float[] floatArrayConcat(float[] a, float[] b){
		float res[] = new float[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}

	private short[] shortArrayConcat(short[] a, short[] b){
		short res[] = new short[a.length + b.length];
		System.arraycopy(a, 0, res, 0, a.length);
		System.arraycopy(b, 0, res, a.length, b.length);
		return res;
	}
	
	
}
